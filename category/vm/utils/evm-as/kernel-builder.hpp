// Copyright (C) 2025 Category Labs, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <category/vm/utils/evm-as.hpp>
#include <category/vm/utils/evm-as/builder.hpp>

#include <iostream>

namespace monad::vm::utils::evm_as
{
    template <Traits traits>
    class KernelBuilder : public EvmBuilder<traits>
    {
    public:
        // This results in sequence repetitions close to 1000:
        static constexpr size_t inner_loop_unroll = 47;

        // Together with the chosen value of `inner_loop_unroll`,
        // this gives a good number of sequence repetitions:
        static constexpr size_t max_args_size = 10;

        static size_t get_max_stack_values(size_t args_size)
        {
            // Having `max_stack_values <= 1000` and close to `1000` should
            // leave plenty of stack space for the instruction sequence.
            size_t const total_args_per_inner_loop_iter =
                inner_loop_unroll * (args_size == 0 ? 1 : args_size);
            MONAD_VM_ASSERT(total_args_per_inner_loop_iter <= 1000);
            return total_args_per_inner_loop_iter *
                   (1000 / total_args_per_inner_loop_iter);
        }

        // The number of times the instruction sequence is executed
        static size_t
        get_sequence_repetition_count(size_t args_size, size_t calldata_size)
        {
            size_t const max_stack_values = get_max_stack_values(args_size);
            return (max_stack_values *
                    (calldata_size / (32 * max_stack_values))) /
                   (args_size == 0 ? 1 : args_size);
        }

        // Maximum number of addresses in `address_store`. This constant value
        // can be increased, if needed for something.
        static constexpr size_t max_address_store_size = 3;

        // Hardcoded memory slots used by generated programs.
        static constexpr size_t memory_slot_i = max_address_store_size * 32;
        static constexpr size_t memory_slot_s = memory_slot_i + 32;
        static constexpr size_t memory_slot_c0 = memory_slot_s + 32;

        // * `2` slots for memory_slot_i and memory_slot_s
        // * `inner_loop_unroll` slots for `memory_slot_c0`:
        static constexpr size_t reserved_memory_slots = 2 + inner_loop_unroll;

        // Offset to free memory. All memory slots starting from
        // `free_memory_start` index are untouched by the programs
        // generated by kernel builder.
        static constexpr size_t free_memory_start =
            (max_address_store_size + reserved_memory_slots) * 32;

        // Arbitrary, but without using a lot of gas/time:
        static constexpr size_t resulting_memory_size = 32 * 10;

        KernelBuilder &store_address(std::string const &target)
        {
            size_t const offset = address_store.size() * 32;
            auto const [_, inserted] = address_store.insert({target, offset});
            if (!inserted) {
                std::cerr << std::format(
                                 "[store_address] failed to store address of "
                                 "'{}'. Duplicated target?",
                                 target)
                          << std::endl;
                std::abort();
            }
            MONAD_VM_ASSERT(address_store.size() <= max_address_store_size);
            this->push(target).push(static_cast<uint64_t>(offset)).mstore();
            return *this;
        }

        KernelBuilder &load_address(std::string const &target)
        {
            auto const it = address_store.find(target);
            if (it == address_store.end()) {
                std::cerr << std::format(
                                 "[load_address] failed to load address of "
                                 "'{}'. Undefined target?",
                                 target)
                          << std::endl;
                std::abort();
            }
            this->push(it->second).mload();
            return *this;
        }

        // Build a program for testing the throughput of `sequence`, which is
        // expected to consume `args_size` number of stack elements, for
        // `0 <= args_size <= 10`. The instruction sequence is moreover
        // expected to push a result if and only if `has_output` is true.
        KernelBuilder &throughput(
            EvmBuilder<traits> const &sequence, size_t args_size,
            bool has_output)
        {
            check_args_size_upper_bound(args_size);

            size_t const max_stack_values = get_max_stack_values(args_size);

            this->comment("Opacify jumpdest addresses");
            store_address("inner-loop")
                .store_address("inner-cond")
                .comment("Initialize: i = 0, s = 0")
                .push0()
                .push0();

            // Outer loop
            this->comment("Type: [s, i]");
            this->jumpdest("outer-loop")
                .dup2() // [i, s, i]
                .push(32 * max_stack_values + 1) // [x + 1, i, s, i]
                .add() // [x + 1 + i, s, i]
                .calldatasize() // [N, x + 1 + i, s, i]
                .push(1) // [1, N, x + 1 + i, s, i]
                .add() // [1 + N, x + 1 + i, s, i]
                .lt() // [N <= x + i, s, i]
                .jumpi("return-result");

            // Data loop
            this->comment(
                "Push " + std::to_string(max_stack_values) +
                " call data values onto the stack");
            this->jumpdest("data-loop");
            // [s, i]
            for (size_t c = 0; c < args_size; ++c) {
                // [s, i, CD(c), CD(c-1), ..., CD(1)]
                this->dup2(); // [i, s, i, CD(c), CD(c-1), ..., CD(1)]
                this->calldataload(); // [CD(c+1), s, i, CD(c), CD(c-1), ...,
                                      // CD(1)]
                this->swap2(); // [i, s, CD(c+1), CD(c), CD(c-1), ..., CD(1)]
                this->push(
                    32); // [32, i, s, CD(c+1), CD(c), CD(c-1), ..., CD(1)]
                this->add(); // [i + 32, s, CD(c+1), CD(c), CD(c-1), ..., CD(1)]
                this->swap1(); // [s, i + 32, CD(c+1), CD(c), CD(c-1), ...,
                               // CD(1)]
            }
            if (args_size == 0) {
                // [s, i]
                this->swap1();
                // [i, s]
                this->push(32).add();
                // [i + 32, s]
                this->swap1();
                // [s, i + 32]
            }
            // [s, i, CD(n), CD(n-1), ..., CD(1)]
            for (size_t c = 0; c < args_size / 2; ++c) {
                this->swap(2 + c);
                // [CD(n), i, s, CD(n-1), ..., CD(1)]
                this->swap(1 + args_size - c);
                // [CD(1), i, s, CD(n-1), ..., CD(n)]
                this->swap(2 + c);
                // [s, i, CD(1), CD(n-1), ..., CD(n)]
            }
            // [s, i, CD(1), CD(2), ..., CD(n)]
            this->push(args_size == 0 ? 1 : args_size); // [n, s, i, ...]
            this->add(); // [n + s, i, ...]
            this->dup1(); // [n + s, n + s, i, ...]
            this->push(max_stack_values);
            // [max_stack_values, n + s, n + s, i, ...]
            this->gt();
            // [max_stack_values > n + s, n + s, i, ...]
            this->jumpi("data-loop"); // [n + s, i, ...]

            // [max_stack_values, i, ...]
            this->pop(); // [i, ...]
            this->push(memory_slot_i).mstore();
            this->push0().push(memory_slot_s).mstore();

            this->comment("Perform a dynamic jump to inner-loop");
            this->load_address("inner-loop").jump();

            // Inner loop
            this->comment("Type: [d1, d2, d3, ...]");
            this->jumpdest("inner-loop");
            for (size_t c = 0; c < inner_loop_unroll; ++c) {
                // [d1, d2, d3, ..., dn, d(n+1), d(n+2), ...]
                this->append(sequence);
                // [opt_result, d(n+1), d(n+2), ...]
                if (has_output) {
                    this->push(memory_slot_c0 + c * 32).mstore();
                }
                // [d(n+1), d(n+2), ...]
            }

            this->comment("Jump to inner-cond");
            load_address("inner-cond").jump();

            // Inner loop condition
            this->jumpdest("inner-cond");
            this->push(memory_slot_s).mload(); // [s]
            this->push(
                inner_loop_unroll * (args_size == 0 ? 1 : args_size)); // [x, s]
            this->add(); // [x + s]
            this->dup1(); // [x + s, x + s]
            this->push(memory_slot_s).mstore(); // [x + s]
            this->push(max_stack_values); // [max_stack_values, x + s]
            this->gt(); // [max_stack_values > x + s]
            this->jumpi("inner-loop");

            this->push(memory_slot_i).mload(); // [i]
            this->push0(); // [0, i]
            this->jump("outer-loop");

            // Result block
            this->jumpdest("return-result");
            this->push(resulting_memory_size);
            this->push(free_memory_start);
            this->return_();

            return *this;
        }

        // Make a program which can be used to transform calldata into
        // the form required by the program built by `latency` below.
        // After executing the program built by `latency_calldata`, the
        // return data contains the transformed calldata.
        KernelBuilder &
        latency_calldata(EvmBuilder<traits> const &sequence, size_t args_size)
        {
            check_args_size_upper_bound(args_size);
            check_args_size_lower_bound(args_size);

            auto const max_stack_values = get_max_stack_values(args_size);

            this->push0();
            this->push0();
            this->jumpdest("outer-loop"); // [p, i]

            this->dup2(); // [i, p, i]
            this->push(max_stack_values * 32); // [x, i, p, i]
            this->add(); // [x + i, p, i]
            this->dup1(); // [x + i, x + i, p, i]
            this->push(1).add(); // [x + i + 1, x + i, p, i]
            this->calldatasize(); // [N, x + i + 1, x + i, p, i]
            this->lt(); // [N <= x + i, x + i, p, i]
            this->jumpi("return-result");

            this->jumpdest("inner-loop");
            // [j, p, i]
            for (size_t c = 0; c < args_size; ++c) {
                this->push(32).swap1().sub(); // [j - 32, p, i]
                this->dup1(); // [j - 32, j - 32, p, i]
                this->calldataload(); // [CD, j - 32, p, i]
                this->dup1(); // [CD, CD, j - 32, p, i]
                this->dup4(); // [p, CD, CD, j - 32, p, i]
                this->xor_(); // [XOR(p, CD), CD, j - 32, p, i]
                this->dup3(); // [j - 32, XOR(p, CD), CD, j - 32, p, i]
                this->mstore(); // [CD, j - 32, p, i]
                this->swap3(); // [i, j - 32, p, CD]
                this->swap2(); // [p, j - 32, i, CD]
                this->swap1(); // [j - 32, p, i, CD]
            }
            // [j', p, i, CD(n), ..., CD(1)]
            this->swap1();
            // [p, j', i, CD(n), ..., CD(1)]
            this->pop();
            // [j', i, CD(n), ..., CD(1)]
            for (size_t c = 0; c < (args_size + 1) / 2; ++c) {
                this->swap(1 + c);
                // [i, j', CD(n), ..., CD(1)]
                this->swap(args_size + 1 - c);
                // [CD(1), j', CD(n), ..., CD(2), i]
                this->swap(1 + c);
                // [j', CD(1), CD(n), ..., CD(2), i]
            }
            // [j', CD(1), ..., CD(n), i]
            for (size_t c = 0; c < args_size; ++c) {
                this->swap(args_size - c);
                // [CD(n), CD(1), ..., j', i]
            }
            // [CD(1), ..., CD(n), j', i]
            this->append(sequence);
            // [p', j', i]
            this->swap1();
            // [j', p', i]
            this->dup3().dup2();
            // [j', i, j', p', i]
            this->eq();
            // [j' == i, j', p', i]
            this->iszero();
            // [j' != i, j', p', i]
            this->jumpi("inner-loop");
            // [j', p', i]
            this->pop();
            // [p', i]
            this->swap1();
            // [i, p']
            this->push(max_stack_values * 32).add();
            // [i + x, p']
            this->swap1();
            // [p' i + x]
            this->jump("outer-loop");

            this->jumpdest("return-result"); // [x + i, p, i]
            this->pop().pop(); // [i]
            this->push0(); // [0, i]
            this->return_();

            return *this;
        }

        // Build a program for testing the latency of `sequence`, which is
        // expected to consume `args_size` number of stack elements, for
        // `1 <= args_size <= 10`. The instruction sequence is required to
        // push a result.
        KernelBuilder &
        latency(EvmBuilder<traits> const &sequence, size_t args_size)
        {
            check_args_size_upper_bound(args_size);
            check_args_size_lower_bound(args_size);

            size_t const max_stack_values = get_max_stack_values(args_size);

            this->comment("Opacify jumpdest addresses");
            store_address("inner-loop")
                .store_address("inner-cond")
                .store_address("outer-loop")
                .comment("Initialize: i = 0, s = 0, p = 0")
                .push0()
                .push0()
                .push0(); // [p = 0, s = 0, i = 0]

            this->swap2(); // [i, s, p]
            this->dup2(); // [p, i, s, p]
            this->xor_(); // [XOR(p, i), s, p]
            this->swap2(); // [p, s, XOR(p, i)]
            load_address("outer-loop").jump();

            // Outer loop
            this->comment("outer-loop, type: [p, s, XOR(p, i)]");
            this->jumpdest("outer-loop")
                .swap2() // [XOR(p, i), s, p]
                .dup3() // [p, XOR(p, i), s, p]
                .xor_() // [i, s, p]
                .swap2() // [p, s, i]
                .dup3() // [i, p, s, i]
                .push(32 * max_stack_values + 1) // [x + 1, i, p, s, i]
                .add() // [x + 1 + i, p, s, i]
                .calldatasize() // [N, x + 1 + i, p, s, i]
                .lt() // [N <= x + i, p, s, i]
                .jumpi("return-result"); // [p, s, i]

            // Data loop
            this->comment(
                "Push " + std::to_string(max_stack_values) +
                " call data values onto the stack");
            this->comment("data-loop, type: [p, s, i]");
            this->jumpdest("data-loop");

            for (size_t c = 0; c < args_size; ++c) {
                // [p, s, i]
                this->dup3();
                // [i, p, s, i]
                this->calldataload();
                // [CD, p, s, i]
                this->swap3();
                // [i, p, s, CD]
                this->push(32);
                // [32, i, p, s, CD]
                this->add();
                // [32 + i, p, s, CD]
                this->swap2();
                // [s, p, 32 + i, CD]
                this->swap1();
                // [p, s, 32 + i, CD]
            }
            // [p, s, i, CD(n), ..., CD(1)]
            for (size_t c = 0; c < args_size / 2; ++c) {
                this->swap(3 + c);
                // [CD(n), s, i, p, CD(n-1), ..., CD(1)]
                this->swap(2 + args_size - c);
                // [CD(1), s, i, p, CD(n-1), ..., CD(2), CD(n)]
                this->swap(3 + c);
                // [p, s, i, CD(1), CD(n-1), ..., CD(2), CD(n)]
            }
            // [p, s, i, CD(1), ..., CD(n)]
            this->swap1();
            // [s, p, i, CD(1), ..., CD(n)]
            this->push(args_size);
            // [n, s, p, i, CD(1), ..., CD(n)]
            this->add();
            // [n + s, p, i, CD(1), ..., CD(n)]
            this->swap1();
            // [p, n + s, i, CD(1), ..., CD(n)]
            this->dup2();
            // [n + s, p, n + s, i, CD(1), ..., CD(n)]
            this->push(max_stack_values);
            // [max_stack_values, n + s, p, n + s, i, CD(1), ..., CD(n)]
            this->gt();
            // [max_stack_values > n + s, p, n + s, i, CD(1), ..., CD(n)]
            this->jumpi("data-loop"); // [p, n + s, i, CD(1), ..., CD(n)]

            // Assuming calldata is initialized correctly, we have:
            // [p, s, i, XOR(p, arg(1)), ..., XOR(p, arg(n)), ...]
            this->swap2();
            // [i, s, p, XOR(p, arg(1)), ..., XOR(p, arg(n)), ...]
            this->push(memory_slot_i).mstore();
            // [s, p, XOR(p, arg(1)), ..., XOR(p, arg(n)), ...]
            this->pop();
            // [p, XOR(p, arg(1)), ..., XOR(p, arg(n)), ...]
            this->push0().push(memory_slot_s).mstore();
            // [p, XOR(p, arg(1)), ..., XOR(p, arg(n)), ...]

            load_address("inner-loop").jump();

            // Inner loop
            this->comment(
                "inner-loop, type: [p, XOR(p, arg(1)), ..., XOR(p, "
                "arg(n)), ...]");
            this->jumpdest("inner-loop");
            for (size_t c = 0; c < inner_loop_unroll; c++) {
                this->comment(std::format("Instruction sequence {}", c + 1));
                // [p, XOR(p, arg(1)), ..., XOR(p, arg(n)), ...]
                for (size_t d = 1; d <= args_size; ++d) {
                    this->dup1();
                    // [p, p, XOR(p, arg(1)), ..., XOR(p, arg(n)), ...]
                    this->swap(d + 1);
                    // [XOR(p, arg(1)), p, p, XOR(p, arg(2)), ..., XOR(p,
                    // arg(n)), ...]
                    this->xor_();
                    // [arg(1), p,  XOR(p, arg(2)), ..., XOR(p, arg(n)), ...]
                    this->swap(d);
                    // [p, arg(1), XOR(p, arg(2)), ..., XOR(p, CD(n)), ...]
                }
                // [p, arg(1), ..., arg(n), ...]
                this->pop();
                // [arg(1), ..., arg(n), ...]
                this->append(sequence);
                // [p', ...]
            }

            this->comment("Jump to inner-cond");
            load_address("inner-cond").jump();

            // Inner loop condition
            this->comment("inner-cond: type [p, ...]");
            this->jumpdest("inner-cond");
            this->push(memory_slot_s).mload(); // [s, p, ...]
            this->push(inner_loop_unroll * args_size); // [x, s, p, ...]
            this->add(); // [x + s, p, ...]
            this->dup1(); // [x + s, x + s, p, ...]
            this->push(memory_slot_s).mstore(); // [x + s, p, ...]
            this->push(max_stack_values); // [max_stack_values, x + s, p, ...]
            this->gt(); // [max_stack_values > x + s, p, ...]
            this->jumpi("inner-loop"); // [p, ...]

            this->push0(); // [0, p]
            this->push(memory_slot_i).mload(); // [i, 0, p]
            this->dup3(); // [p, i, 0, p]
            this->xor_(); // [XOR(p, i), 0, p]
            this->swap2(); // [p, 0, XOR(p, i)]
            load_address("outer-loop").jump();

            // Result block
            this->jumpdest("return-result");
            this->push(resulting_memory_size);
            this->push(free_memory_start);
            this->return_();

            return *this;
        }

    private:
        void check_args_size_upper_bound(size_t args_size) const
        {
            if (args_size > max_args_size) {
                std::cerr << "too many sequence arguments: " << args_size
                          << std::endl;
                std::abort();
            }
        }

        void check_args_size_lower_bound(size_t args_size) const
        {
            if (args_size == 0) {
                std::cerr << "too few sequence arguments: " << args_size
                          << std::endl;
                std::abort();
            }
        }

        std::unordered_map<std::string, size_t> address_store{};
    };
}
